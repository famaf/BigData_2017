{"paragraphs":[{"text":"print(\"\"\"%html\n<center>\n    <h1>Programación Distribuida sobre Grandes Volúmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de Matemática Astronomía Física y Computación\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de Córdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> Damián Barsotti - Ezequiel Orbe </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n\"\"\")","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<center>\n    <h1>Programación Distribuida sobre Grandes Volúmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de Matemática Astronomía Física y Computación\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de Córdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> Damián Barsotti - Ezequiel Orbe </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n"}]},"apps":[],"jobName":"paragraph_1506720280091_-1865429369","id":"20160909-115141_63959255","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:26"},{"text":"%md\n## ~.- Variables Compartidas\n\n**Problema:**\n* Las funciones que se ejecutan en el cluster trabajan sobre copias distintas de todas las variables.\n* Lo mismo ocurre con las variables clausuradas.\n* Los cambios en las variables **no se propagan**.\n\n**Solución:**\n* Spark provee dos tipos de **variables compartidas**: acumuladores y variables de broadcast.","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>~.- Variables Compartidas</h2>\n<p><strong>Problema:</strong></p>\n<ul>\n<li>Las funciones que se ejecutan en el cluster trabajan sobre copias distintas de todas las variables.</li>\n<li>Lo mismo ocurre con las variables clausuradas.</li>\n<li>Los cambios en las variables <strong>no se propagan</strong>.</li>\n</ul>\n<p><strong>Solución:</strong></p>\n<ul>\n<li>Spark provee dos tipos de <strong>variables compartidas</strong>: acumuladores y variables de broadcast.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1506720280105_-1884666814","id":"20161003-202954_1758648551","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27"},{"text":"%md\n### Acumuladores\n\n* Variables compartidas \n    - De **solo escritura** para los workers.\n    - De **solo lectura** para el driver.\n* Los workers agregan usando el método `+=`.\n* El driver lee usando el método `value()`\n* Spark provee acumuladores de distintos tipos: `Integer`, `Long`, `Float` y `Double`\n* Se pueden crear acumuladores de distinto tipo usando una API provista por Spark.\n    - En Spark 1.6.2: Se debe extender `AccumulatorParam` (ver [doc](http://spark.apache.org/docs/1.6.2/programming-guide.html#accumulators)).\n    - En Spark 2.0: Se debe extender `AccumulatorV2` (ver [doc](http://spark.apache.org/docs/2.0.0/programming-guide.html#accumulators)).\n    - La operacion de agregación debe ser conmutativa y asociativa.\n\n<br>\n* Si se crea el acumulador con un nombre se puede ver en la SparkUI los valores que toma.\n    - No implementado en python.\n<br>\n* Qué pasa con los acumuladores cuando Spark reejecuta una tarea?\n    - Si el acumulador se usa en una **acción**, se asegura que solo se actualiza un vez.\n    - Si el acumulador se usa en una **transformación**,  NO se puede asegurar que se actualice una sola vez (ej cuenta de más).\n    - Por lo tanto, si se usan en transformaciones: solo para *debugging*.\n    - Mismo comportamiento en Spark 2.0.","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":6,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h3>Acumuladores</h3>\n<ul>\n<li>Variables compartidas<ul>\n<li>De <strong>solo escritura</strong> para los workers.</li>\n<li>De <strong>solo lectura</strong> para el driver.</li>\n</ul>\n</li>\n<li>Los workers agregan usando el método <code>+=</code>.</li>\n<li>El driver lee usando el método <code>value()</code></li>\n<li>Spark provee acumuladores de distintos tipos: <code>Integer</code>, <code>Long</code>, <code>Float</code> y <code>Double</code></li>\n<li>Se pueden crear acumuladores de distinto tipo usando una API provista por Spark.<ul>\n<li>En Spark 1.6.2: Se debe extender <code>AccumulatorParam</code> (ver <a href=\"http://spark.apache.org/docs/1.6.2/programming-guide.html#accumulators\">doc</a>).</li>\n<li>En Spark 2.0: Se debe extender <code>AccumulatorV2</code> (ver <a href=\"http://spark.apache.org/docs/2.0.0/programming-guide.html#accumulators\">doc</a>).</li>\n<li>La operacion de agregación debe ser conmutativa y asociativa.</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li>Si se crea el acumulador con un nombre se puede ver en la SparkUI los valores que toma.<ul>\n<li>No implementado en python.\n<br  /><br></li>\n</ul>\n</li>\n<li>Qué pasa con los acumuladores cuando Spark reejecuta una tarea?<ul>\n<li>Si el acumulador se usa en una <strong>acción</strong>, se asegura que solo se actualiza un vez.</li>\n<li>Si el acumulador se usa en una <strong>transformación</strong>,  NO se puede asegurar que se actualice una sola vez (ej cuenta de más).</li>\n<li>Por lo tanto, si se usan en transformaciones: solo para <em>debugging</em>.</li>\n<li>Mismo comportamiento en Spark 2.0.</li>\n</ul>\n</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1506720280107_-1883897316","id":"20160909-120251_868293167","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:28"},{"text":"// Lee logs con call signs\nval inputFile = \"/Users/ezequielorbe/Teaching/Spark2016/bigdata/posgrado_optativa/lectivo/presentaciones/07_rdd_avanzada/callsigns\"\n\nval file = sc.textFile(inputFile)\n\n// Crea Accumulator[Int] initialisad a 0\nval blankLines = sc.accumulator(0, \"blanklines\")\nval dataLines = sc.accumulator(0, \"datalines\")\n\nval callSigns = file.flatMap(line => {\n  if (line == \"\") {\n    blankLines += 1\n  } else {\n    dataLines +=1\n  }\n  line.split(\" \")\n})\n\ncallSigns.collect // se fuerza la evaluación\n\nprintln(\"Lineas en blanco: \" + blankLines.value)\nprintln(\"Lineas con datos: \" + dataLines.value)\n","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":6,"editorMode":"ace/mode/scala","lineNumbers":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1506720280109_-1886205809","id":"20160908-171223_1492440579","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:29"},{"text":"%md\n### Variables Broadcast\n\n* Permiten al driver enviar eficientemente datos de solo lectura a todos los workers.\n* Se envia solo una vez a cada nodo.\n* Util cuando las tasks dentro de un stage necesitan acceder repetidamente un mismo dataset (e.g. un dataset para hacer lookup).\n* Una variable de broadcast es un objeto de tipo `spark.broadcast.Broadcast[T]` que \"wrapea\" un valor de tipo `T`.\n    - Se accede al valor mediante el método `value()`.   \n* **Importante:** \n    - La variable **debe** tratarse como de solo lectura. \n    - Spark no obliga a esto.\n* Cuando el tamaño del broadcast es importante es importante elegir un formato de serialización eficiente.\n","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h3>Variables Broadcast</h3>\n<ul>\n<li>Permiten al driver enviar eficientemente datos de solo lectura a todos los workers.</li>\n<li>Se envia solo una vez a cada nodo.</li>\n<li>Util cuando las tasks dentro de un stage necesitan acceder repetidamente un mismo dataset (e.g. un dataset para hacer lookup).</li>\n<li>Una variable de broadcast es un objeto de tipo <code>spark.broadcast.Broadcast[T]</code> que &ldquo;wrapea&rdquo; un valor de tipo <code>T</code>.<ul>\n<li>Se accede al valor mediante el método <code>value()</code>.</li>\n</ul>\n</li>\n<li><strong>Importante:</strong><ul>\n<li>La variable <strong>debe</strong> tratarse como de solo lectura.</li>\n<li>Spark no obliga a esto.</li>\n</ul>\n</li>\n<li>Cuando el tamaño del broadcast es importante es importante elegir un formato de serialización eficiente.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1506720280111_-1885436312","id":"20160909-123452_805434953","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:30"},{"text":"def loadCallSignTable() = {\n    scala.io.Source.fromFile(\"/Users/ezequielorbe/Teaching/Spark2016/bigdata/posgrado_optativa/lectivo/presentaciones/07_rdd_avanzada/callsign_tbl_sorted\").getLines()\n        .filter(_ != \"\").toArray\n}\n\ndef lookupInArray(sign: String, prefixArray: Array[String]): String = {\n    val pos = java.util.Arrays.binarySearch(prefixArray.asInstanceOf[Array[AnyRef]], sign) match {\n      case x if x < 0 => -x-1\n      case x => x\n    }\n    // The country is the second element separated by comma\n    prefixArray(pos).split(\",\")(1)\n}\n\n// Busco paises para cada call sign en el\n// contactCounts RDD.  Se carga en un array de call sign\n// los prefijos de los códigos de los paises para hacer la búsqueda.\nval signPrefixes = sc.broadcast(loadCallSignTable())\n\n// accumulators con nombre:\nval validSignCount = sc.accumulator(0,\"validSignCount\")\nval invalidSignCount = sc.accumulator(0,\"invalidSignCount\")\n\n// Valida los call sign\nval callSignRegex = \"\\\\A\\\\d?[a-zA-Z]{1,2}\\\\d{1,4}[a-zA-Z]{1,3}\\\\Z\".r\n\n// Filtro los incorrectos\nval validSigns = callSigns.filter{sign =>\n      if ((callSignRegex findFirstIn sign).nonEmpty) {\n        validSignCount += 1; true\n      } else {\n        invalidSignCount += 1; false\n      }\n}\n\n// Cuenta la cantidad de apariciones en log de cada call sign\nval contactCounts = validSigns.map(callSign => (callSign, 1)).reduceByKey((x, y) => x + y)\n\n\nval countryContactCounts = contactCounts.map{case (sign, count) =>\n        val country = lookupInArray(sign, signPrefixes.value)\n        (country, count)\n}.reduceByKey((x, y) => x + y) \n\n\ncountryContactCounts.saveAsTextFile(\"/Users/ezequielorbe/Teaching/Spark2016/bigdata/posgrado_optativa/lectivo/presentaciones/07_rdd_avanzada/paises.txt\")","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1506720280113_-1875432840","id":"20161005-001338_170145441","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:31"},{"text":"%md\n## ~.- Operaciones por partición\n\n* Las transformaciones `map` y `foreach` trabajan a nivel de cada elemento de una partición, \n    - Aplican una funcion por cada elemento dentro de una partición. \n* También existen transformaciones que trabajan a nivel de partición.\n    - Aplican una función a todos los elementos de una partición. \n* Son ideales para implementar operaciones de setup costosas.\n    - Conexion a base de datos.\n    - Generación de números aleatorios.\n* Operaciones:\n    - `mapPartitions`\n    - `mapPartitionsWithIndex`\n    - `foreachPartition`\n","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":6,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>~.- Operaciones por partición</h2>\n<ul>\n<li>Las transformaciones <code>map</code> y <code>foreach</code> trabajan a nivel de cada elemento de una partición,<ul>\n<li>Aplican una funcion por cada elemento dentro de una partición.</li>\n</ul>\n</li>\n<li>También existen transformaciones que trabajan a nivel de partición.<ul>\n<li>Aplican una función a todos los elementos de una partición.</li>\n</ul>\n</li>\n<li>Son ideales para implementar operaciones de setup costosas.<ul>\n<li>Conexion a base de datos.</li>\n<li>Generación de números aleatorios.</li>\n</ul>\n</li>\n<li>Operaciones:<ul>\n<li><code>mapPartitions</code></li>\n<li><code>mapPartitionsWithIndex</code></li>\n<li><code>foreachPartition</code></li>\n</ul>\n</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1506720280114_-1874278594","id":"20160909-124814_29426618","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:32"},{"text":"%md\n### `mapPartitions`\n\nDado un `RDD[T]` `mapPartitions` toma un función de tipo\n<br>\n```scala\nf: Iterator[T] ⇒ Iterator[U]\n```\ny devuelve un `RDD[U]`.\n<br>\n\nEl siguiente ejemplo se llena el pais de cada *call sign* pero el pais se toma de sitio web externo.\n","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":6,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h3><code>mapPartitions</code></h3>\n<p>Dado un <code>RDD[T]</code> <code>mapPartitions</code> toma un función de tipo\n<br  /><br></p>\n<pre><code class=\"scala\">f: Iterator[T] ⇒ Iterator[U]\n</code></pre>\n<p>y devuelve un <code>RDD[U]</code>.\n<br  /><br></p>\n<p>El siguiente ejemplo se llena el pais de cada <em>call sign</em> pero el pais se toma de sitio web externo.</p>\n"}]},"apps":[],"jobName":"paragraph_1506720280116_-1876587087","id":"20160909-125803_1892922832","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:33"},{"text":"import scalaj.http._\nimport scala.util.parsing.json._\n\nval countryContactCounts = contactCounts.mapPartitions{\n    signsCounts =>\n        signsCounts.map {\n             case (sign,count) => {\n                val url = s\"http://new73s.herokuapp.com/qsos/${sign}.json\"            \n                val response = JSON.parseFull(Http(url).asString.body) match {\n                        case None => (\"N/A\")\n                        case Some(value) => {\n                            val data = value.asInstanceOf[List[Map[String, Any]]]\n                            data(0).getOrElse(\"country\",\"N/A\").asInstanceOf[String]\n                        }\n                    }\n                (sign,response)\n             }\n        }\n}\ncountryContactCounts.collect\n","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1506720280117_-1876971836","id":"20161004-224209_1414444602","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:34"},{"title":"FIN","text":"print(\"\"\"%html\n<script>\n    var heads = document.getElementsByTagName('h2');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        if (inner.search(\".-\") != -1 ) {\n            j++;\n            heads[i].innerHTML = inner.replace(/(~|\\d+)\\.-/,\"\"+j+\".-\");\n        }\n        i++\n    }\n</script>\n\"\"\")","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<script>\n    var heads = document.getElementsByTagName('h2');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        if (inner.search(\".-\") != -1 ) {\n            j++;\n            heads[i].innerHTML = inner.replace(/(~|\\d+)\\.-/,\"\"+j+\".-\");\n        }\n        i++\n    }\n</script>\n"}]},"apps":[],"jobName":"paragraph_1506720280118_-1875817589","id":"20160908-183527_570322694","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:35"},{"text":"","dateUpdated":"2017-09-29T18:24:40-0300","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1506720280120_-1878126083","id":"20160909-123003_1977756364","dateCreated":"2017-09-29T18:24:40-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:36"}],"name":"Presentación 06 - RDD Avanzada","id":"2CWBXBV73","angularObjects":{"2CQY683MD:shared_process":[],"2CRGPDJTN:shared_process":[],"2CTZD3XCX:shared_process":[],"2CRMCDEQM:shared_process":[],"2CTAV9E28:shared_process":[],"2CRA7KCDA:shared_process":[],"2CQ81X7G5:shared_process":[],"2CRUQ6EVN:shared_process":[],"2CTHYC7X9:shared_process":[],"2CRHWDFYM:shared_process":[],"2CQJ7MXW5:shared_process":[],"2CQAR5VSM:shared_process":[],"2CRCFF6HB:shared_process":[],"2CTK8TR8Q:shared_process":[],"2CQN5Q87B:shared_process":[],"2CTW5YZGW:shared_process":[],"2CSR7EJVT:shared_process":[],"2CRUQ7EXT:shared_process":[],"2CRFFBRXJ:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}