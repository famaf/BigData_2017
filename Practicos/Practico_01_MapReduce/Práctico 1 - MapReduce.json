{"paragraphs":[{"text":"val baseDir=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/03_rdd_notebook\"\nprint(\"\"\"%html\n<center>\n    <h1>Programación Distribuida sobre Grandes Volúmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de Matemática Astronomía Física y Computación\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de Córdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> Damián Barsotti  </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n\"\"\")\n","dateUpdated":"2017-08-23T18:16:53-0300","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<center>\n    <h1>Programación Distribuida sobre Grandes Volúmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de Matemática Astronomía Física y Computación\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de Córdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> Damián Barsotti  </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n"}]},"apps":[],"jobName":"paragraph_1503523013064_1037717406","id":"20160720-131723_1132815368","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:5973"},{"text":"%md\n# Práctico 1 \n\n## MapReduce\n\nEn este práctico se desarrollarán ejercicios para implementar algunos algoritmos MapReduce. Además se practicará la construcción de programas en Scala.\nPara hacer el práctico tener en cuenta:\n* Se recomienda fuertemente haber hecho el tutorial de Scala.\n* Para correr los programa debe usar **[`Shift`]-[`Enter`]** o cliquear el triangulito arriba a la derecha de la celda (RUN).\n* Para hacer copy and paste desde el notebook seleccionar con **[`Ctrl`]-[flechitas]** y hacer **[`Ctrl`]-[`c`]** y **[`Ctrl`]-[`v`]**.\n\n","dateUpdated":"2017-08-23T18:16:53-0300","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>Práctico 1</h1>\n<h2>MapReduce</h2>\n<p>En este práctico se desarrollarán ejercicios para implementar algunos algoritmos MapReduce. Además se practicará la construcción de programas en Scala.\n<br  />Para hacer el práctico tener en cuenta:</p>\n<ul>\n<li>Se recomienda fuertemente haber hecho el tutorial de Scala.</li>\n<li>Para correr los programa debe usar <strong>[<code>Shift</code>]-[<code>Enter</code>]</strong> o cliquear el triangulito arriba a la derecha de la celda (RUN).</li>\n<li>Para hacer copy and paste desde el notebook seleccionar con <strong>[<code>Ctrl</code>]-[flechitas]</strong> y hacer <strong>[<code>Ctrl</code>]-[<code>c</code>]</strong> y <strong>[<code>Ctrl</code>]-[<code>v</code>]</strong>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503523013080_1043873388","id":"20160615-144959_2134148107","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5974"},{"text":"%md\n### Implementación naif del patrón MapReduce\n\nA continuación se dará una implementación muy simple del patrón en Scala. La misma corre solo en una máquina, sin file system distribuido y solo nos servirá para practicar su uso.\nLea el código y trate de entenderlo. Comparelo también con la presentación en clase del tema. Cualquier duda consulte un docente.\n","dateUpdated":"2017-08-23T18:16:53-0300","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Implementación naif del patrón MapReduce</h3>\n<p>A continuación se dará una implementación muy simple del patrón en Scala. La misma corre solo en una máquina, sin file system distribuido y solo nos servirá para practicar su uso.<br/>Lea el código y trate de entenderlo. Comparelo también con la presentación en clase del tema. Cualquier duda consulte un docente.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503523013081_1043488639","id":"20160615-145043_1018834183","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5975"},{"text":"// Funcion map comun pero que devuelve lista de pares (clave,valor)\ndef elMap[Kin,Vin,Kout,Vout]\n    (datosIn: List[(Kin,Vin)])\n    (fmap : (Kin,Vin) => List[(Kout,Vout)])\n    : List[(Kout,Vout)]\n    = datosIn.flatMap(kv => fmap(kv._1,kv._2)) // Cannot use just f, something wierd with implicits\n\n// Agrupa los valores que tienen clave comun\ndef agrupa[Kout,Vout]\n    (kvs : List[(Kout,Vout)])\n    : Map[Kout,List[Vout]]\n    = kvs.groupBy(_._1).mapValues(_.unzip._2)\n\n//    = kvs.groupBy(_._1).mapValues(_.map(_.2))\n\n// Para cada clave aplico una operacion a su lista de valores\ndef reduce[Kout,Vout,VFin]\n    (kvss : Map[Kout,List[Vout]])\n    (freduce : (Kout,  List[Vout]) => VFin)\n    : List[VFin]\n    = kvss.map({case (k,vs) => freduce(k,vs)}).toList\n\n//Junto todo\ndef mapReduce[Kin,Vin,Kout,Vout,VFin]\n    (datosIn: List[(Kin,Vin)])\n    (fmap : (Kin,Vin) => List[(Kout,Vout)])\n    (freduce : (Kout,  List[Vout]) => VFin)\n    : List[VFin]\n    = {\n        val resMap = elMap (datosIn) (fmap)\n        println(resMap)\n        val resAgrupo  = agrupa(resMap)\n        val resReduce = reduce (resAgrupo) (freduce)\n        return resReduce\n    }","user":"anonymous","dateUpdated":"2017-08-24T00:23:11-0300","config":{"editorSetting":{"language":"scala"},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nelMap: [Kin, Vin, Kout, Vout](datosIn: List[(Kin, Vin)])(fmap: (Kin, Vin) => List[(Kout, Vout)])List[(Kout, Vout)]\n\nagrupa: [Kout, Vout](kvs: List[(Kout, Vout)])Map[Kout,List[Vout]]\n\nreduce: [Kout, Vout, VFin](kvss: Map[Kout,List[Vout]])(freduce: (Kout, List[Vout]) => VFin)List[VFin]\n\nmapReduce: [Kin, Vin, Kout, Vout, VFin](datosIn: List[(Kin, Vin)])(fmap: (Kin, Vin) => List[(Kout, Vout)])(freduce: (Kout, List[Vout]) => VFin)List[VFin]\n"}]},"apps":[],"jobName":"paragraph_1503523013082_1044642886","id":"20160615-145341_501086069","dateCreated":"2017-08-23T18:16:53-0300","dateStarted":"2017-08-24T00:23:11-0300","dateFinished":"2017-08-24T00:23:17-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:5976"},{"text":"%md\n### Pequeño ejemplo de uso\n\nA continuación se verá la implementación em MapReduce del algoritmo que encuentra la cantidad de apariciones de cada letra (visto en clase).\nPruebe ejecutarlo llamando a la función `countChar` con un `String` cualquiera.","dateUpdated":"2017-08-23T18:16:53-0300","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Pequeño ejemplo de uso</h3>\n<p>A continuación se verá la implementación em MapReduce del algoritmo que encuentra la cantidad de apariciones de cada letra (visto en clase).<br/>Pruebe ejecutarlo llamando a la función <code>countChar</code> con un <code>String</code> cualquiera.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503523013083_1044258137","id":"20160615-150406_526670902","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5977"},{"text":"// Cuento cantidad de veces que aparece cada letra\n// ===============================================\ndef countChar (str: String) = {\n    val datos = str.toList.map(c => ((),c))\n    val fmap = (_ : Unit, c : Char) => List((c,1))\n    val freduce = (c: Char, vs: List[Int]) => (c,vs.fold (0) (_+_))\n    \n    mapReduce (datos) (fmap) (freduce)\n}\n\ncountChar(\"hoolaa\")\n","user":"anonymous","dateUpdated":"2017-08-24T00:23:20-0300","config":{"editorSetting":{"language":"scala"},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ncountChar: (str: String)List[(Char, Int)]\nList((h,1), (o,1), (o,1), (l,1), (a,1), (a,1))\n\nres16: List[(Char, Int)] = List((h,1), (a,2), (l,1), (o,2))\n"}]},"apps":[],"jobName":"paragraph_1503523013084_1042334393","id":"20160615-151707_1876187925","dateCreated":"2017-08-23T18:16:53-0300","dateStarted":"2017-08-24T00:23:20-0300","dateFinished":"2017-08-24T00:23:22-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:5978"},{"text":"%md\n### Ejercicio ~\n\nEn la celda siguiente modifique el programa anterior para que tome un archivo en vez de un string.\nLa idea es que el `map` trabaje sobre cada linea de texto (no sobre cada caracter).\nNo se puede usar el programa anterior.\nA continuación se muestra un esqueleto del programa que debe completar programando las funciones `fmap` y `freduce`:\n","dateUpdated":"2017-08-23T18:16:53-0300","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Ejercicio ~</h3>\n<p>En la celda siguiente modifique el programa anterior para que tome un archivo en vez de un string.<br/>La idea es que el <code>map</code> trabaje sobre cada linea de texto (no sobre cada caracter).<br/>No se puede usar el programa anterior.<br/>A continuación se muestra un esqueleto del programa que debe completar programando las funciones <code>fmap</code> y <code>freduce</code>:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503523013086_1043103890","id":"20160615-152433_20160637","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5979"},{"text":"def countCharFile (filePath: String) = {\n    \nimport scala.io.Source\n\n    val lines : List[String] = Source.fromFile(filePath).getLines.toList\n    val datos = lines.map(l => ((),l))\n    val fmap = (_ : Unit, l : String) => ...\n    val freduce = (c: Char, vs: List[Int]) => ...\n    mapReduce (datos) (fmap) (freduce)\n}","dateUpdated":"2017-08-23T18:16:53-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503523013088_1028483432","id":"20160615-154328_239768480","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5980"},{"text":"%md\n### Ejercicio ~ (wordCount)\n\nHacer un programa que calcule la cantidad de veces que aparece cada palabra (no vacía) en un archivo.\nA continuación se muestra un esqueleto del programa que debe completar programando las funciones `fmap` y `freduce`.\n\n#### Ayuda\n\n* Para dividir un `String` en palabras se puede usar el método `split`.\n* Para filtrar elementos de una lista se puede usar el método `filter`. \n* Para ver si un `String` no es vacío se puede usar `! _.isEmpty`","user":"anonymous","dateUpdated":"2017-08-24T00:22:35-0300","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Ejercicio ~ (wordCount)</h3>\n<p>Hacer un programa que calcule la cantidad de veces que aparece cada palabra (no vacía) en un archivo.<br/>A continuación se muestra un esqueleto del programa que debe completar programando las funciones <code>fmap</code> y <code>freduce</code>.</p>\n<h4>Ayuda</h4>\n<ul>\n  <li>Para dividir un <code>String</code> en palabras se puede usar el método <code>split</code>.</li>\n  <li>Para filtrar elementos de una lista se puede usar el método <code>filter</code>.</li>\n  <li>Para ver si un <code>String</code> no es vacío se puede usar <code>! _.isEmpty</code></li>\n</ul>\n</div>"}]},"apps":[],"jobName":"paragraph_1503523013089_1028098683","id":"20160616-110119_1095838749","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5981"},{"text":"def wordCount (filePath: String) = {\n\nimport scala.io.Source\n\n    val lines : List[String] = Source.fromFile(filePath).getLines.toList\n    val datos = lines.map(l => ((),l))\n\n    val fmap = (_ : Unit, l : String) => ...\n    val freduce = (w: String, vs: List[Int]) => ...\n\n    mapReduce (datos) (fmap) (freduce)\n}","dateUpdated":"2017-08-23T18:16:53-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503523013090_1029252930","id":"20160616-110138_1909742592","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5982"},{"text":"%md\n### Ejercicio ~ (amigos en común)\n\nDada una lista de tuplas, donde el primer elemento es una persona y el segundo una lista de sus amigos, hacer un programa con `mapReduce` que devuelve la lista de amigos en común de todos los pares de **amigos** posibles.\nLa lista de amigos se almacena de la siguiente forma:\n```scala\nval amigosDe = List(  (\"A\", List(\"B\", \"C\", \"D\"))\n                    , (\"B\", List(\"A\", \"C\", \"D\", \"E\"))\n                    , (\"C\", List(\"A\", \"B\", \"D\", \"E\"))\n                    , (\"D\", List(\"A\", \"B\", \"C\", \"E\"))\n                    , (\"E\", List(\"B\", \"C\", \"D\"))      )\n```\nVer que la relación de amistad tiene que ser simétrica.\n#### Ayuda\nPara cada par `(p,ams)` de la lista de entrada la función `map` puede devolver todas las tuplas posible `({p,am},ams)` donde `{p,am}` es un conjunto de dos persona y `am` es un elemento de `ams`.\nVer que en estos resultados deben aparecer exactamente dos tuplas cuyos primeros elementos (conjunto `{p,am}`) son iguales.\nA partir de esta observación los amigos en común son la intersección de las segundas componentes de ambas tuplas.\nA continuación se da un esqueleto del programa a completar:\n","dateUpdated":"2017-08-23T18:16:53-0300","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":409.05,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Ejercicio ~ (amigos en común)</h3>\n<p>Dada una lista de tuplas, donde el primer elemento es una persona y el segundo una lista de sus amigos, hacer un programa con <code>mapReduce</code> que devuelve la lista de amigos en común de todos los pares de <strong>amigos</strong> posibles.<br/>La lista de amigos se almacena de la siguiente forma:</p>\n<pre><code class=\"scala\">val amigosDe = List(  (&quot;A&quot;, List(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;))\n                    , (&quot;B&quot;, List(&quot;A&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;))\n                    , (&quot;C&quot;, List(&quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;E&quot;))\n                    , (&quot;D&quot;, List(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;E&quot;))\n                    , (&quot;E&quot;, List(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;))      )\n</code></pre>\n<p>Ver que la relación de amistad tiene que ser simétrica.</p>\n<h4>Ayuda</h4>\n<p>Para cada par <code>(p,ams)</code> de la lista de entrada la función <code>map</code> puede devolver todas las tuplas posible <code>({p,am},ams)</code> donde <code>{p,am}</code> es un conjunto de dos persona y <code>am</code> es un elemento de <code>ams</code>.<br/>Ver que en estos resultados deben aparecer exactamente dos tuplas cuyos primeros elementos (conjunto <code>{p,am}</code>) son iguales.<br/>A partir de esta observación los amigos en común son la intersección de las segundas componentes de ambas tuplas.<br/>A continuación se da un esqueleto del programa a completar:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503523013090_1029252930","id":"20160616-144311_939960850","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5983"},{"text":"def amigosEnComun(ade: List[(String,List[String])]) = {\n ...\n}","dateUpdated":"2017-08-23T18:16:53-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503523013091_1028868181","id":"20160616-144334_1113097282","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5984"},{"text":"%md\n### Ejercicio ~ (word co-ocurrencia)\nEn el siguiente ejercicio hay que construir la matriz de *co-ocurrencia* de palabras en una misma linea. Esta es una matriz simétrica `n*n` donde `n` es el número de palabras (sin repetición) en un texto. Para cada par de palabres (fila y columna de la matriz) se cuenta la cantidad de veces que ocurren ambas en una misma linea.\n\n#### Ayuda\nSe puede hacer que la función `fmap` devuelva los pares ordenados de palabras en una misma linea con un contador igual a `1`. Por ejemplo, en la linea `w1 w2 w3 w1` la función producirá: \n`(w1,w2):1, (w1, w3):1, (w1,w1):1, (w2,w3):1, (w1,w2):1, (w1,w3):1`\n\nLa función `freduce` recolectaría estos valores para llenar cada elemento de la matriz.\n\nA continuación se da un esqueleto del programa a completar:","dateUpdated":"2017-08-23T18:16:53-0300","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Ejercicio ~ (word co-ocurrencia)</h3>\n<p>En el siguiente ejercicio hay que construir la matriz de <em>co-ocurrencia</em> de palabras en una misma linea. Esta es una matriz simétrica <code>n*n</code> donde <code>n</code> es el número de palabras (sin repetición) en un texto. Para cada par de palabres (fila y columna de la matriz) se cuenta la cantidad de veces que ocurren ambas en una misma linea.</p>\n<h4>Ayuda</h4>\n<p>Se puede hacer que la función <code>fmap</code> devuelva los pares ordenados de palabras en una misma linea con un contador igual a <code>1</code>. Por ejemplo, en la linea <code>w1 w2 w3 w1</code> la función producirá:<br/><code>(w1,w2):1, (w1, w3):1, (w1,w1):1, (w2,w3):1, (w1,w2):1, (w1,w3):1</code></p>\n<p>La función <code>freduce</code> recolectaría estos valores para llenar cada elemento de la matriz.</p>\n<p>A continuación se da un esqueleto del programa a completar:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503523013091_1028868181","id":"20160616-165559_153544464","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5985"},{"text":"def wordCoOcurrence (filePath: String) = {\n\n   ...\n    mapReduce (datos) (fmap) (freduce)\n}\n","dateUpdated":"2017-08-23T18:16:53-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503523013092_1026944437","id":"20160616-165637_456865360","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5986"},{"text":"%md\n### Ejercicio ~ (promedio)\n\nCon el programa `mapReduce` calcule el promedio de una lista de numeros.\n\nA continuación se da un esqueleto del programa a completar:\n","dateUpdated":"2017-08-23T18:16:53-0300","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Ejercicio ~ (promedio)</h3>\n<p>Con el programa <code>mapReduce</code> calcule el promedio de una lista de numeros.</p>\n<p>A continuación se da un esqueleto del programa a completar:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503523013092_1026944437","id":"20170823-103411_1291391962","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5987"},{"text":"%md\n","user":"anonymous","dateUpdated":"2017-08-24T14:56:13-0300","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503597372994_520872262","id":"20170824-145612_1054631373","dateCreated":"2017-08-24T14:56:12-0300","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:5988"},{"text":"def promedio (nums: List[Double]) : Double = {\n\n    ...\n    ... mapReduce (datos) (fmap) (freduce)\n    return ...\n}\n","dateUpdated":"2017-08-23T18:16:53-0300","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503523013093_1026559688","id":"20170823-103440_918535335","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5989"},{"title":"FIN","text":"println(\"\"\"%html\n<script>\n    var heads = document.getElementsByTagName('h3');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        if (inner.search(\"Ejercicio\") != -1 ) {\n            j++;\n            heads[i].innerHTML = inner.replace(/Ejercicio (~|\\d+)/,\"Ejercicio \"+j);\n        }\n        i++\n    }\n</script>\n\"\"\")\n","dateUpdated":"2017-08-23T18:16:53-0300","config":{"tableHide":true,"editorSetting":{"language":"scala"},"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<script>\n    var heads = document.getElementsByTagName('h3');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        if (inner.search(\"Ejercicio\") != -1 ) {\n            j++;\n            heads[i].innerHTML = inner.replace(/Ejercicio (~|\\d+)/,\"Ejercicio \"+j);\n        }\n        i++\n    }\n</script>\n\n"}]},"apps":[],"jobName":"paragraph_1503523013094_1027713934","id":"20160616-171626_2027424644","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5990"},{"dateUpdated":"2017-08-23T18:16:53-0300","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503523013095_1027329186","id":"20160830-114323_344385570","dateCreated":"2017-08-23T18:16:53-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:5991"}],"name":"Práctico 1 - MapReduce","id":"2CT21SA2Y","angularObjects":{"2CQY683MD:shared_process":[],"2CRGPDJTN:shared_process":[],"2CTZD3XCX:shared_process":[],"2CRMCDEQM:shared_process":[],"2CTAV9E28:shared_process":[],"2CRA7KCDA:shared_process":[],"2CQ81X7G5:shared_process":[],"2CRUQ6EVN:shared_process":[],"2CTHYC7X9:shared_process":[],"2CRHWDFYM:shared_process":[],"2CQJ7MXW5:shared_process":[],"2CQAR5VSM:shared_process":[],"2CRCFF6HB:shared_process":[],"2CTK8TR8Q:shared_process":[],"2CQN5Q87B:shared_process":[],"2CTW5YZGW:shared_process":[],"2CSR7EJVT:shared_process":[],"2CRUQ7EXT:shared_process":[],"2CRFFBRXJ:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}