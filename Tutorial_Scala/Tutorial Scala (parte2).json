{"paragraphs":[{"text":"val baseDir=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/03_rdd_notebook\"\nprint(\"\"\"%html\n<center>\n    <h1>Programación Distribuida sobre Grandes Volúmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de Matemática Astronomía Física y Computación\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de Córdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> Damián Barsotti - Ezequiel Orbe </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n\"\"\")\n","dateUpdated":"2017-08-20T20:10:48-0300","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<center>\n    <h1>Programación Distribuida sobre Grandes Volúmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de Matemática Astronomía Física y Computación\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de Córdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> Damián Barsotti - Ezequiel Orbe </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n"}]},"apps":[],"jobName":"paragraph_1503270648223_1079974037","id":"20160818-202628_810221159","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:10960"},{"text":"%md #Tutorial Scala (parte 2)\n\nEste tutorial de Scala ayudará a entender los conceptos básicos para programar en este lenguaje.\nSe presentarán los temas con la posibilidad de ejecutar y modificar los ejemplos en la misma página de lectura para que pruebe y se familiarice con el lenguaje.","dateUpdated":"2017-08-20T20:10:48-0300","config":{"tableHide":false,"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>Tutorial Scala (parte 2)</h1>\n<p>Este tutorial de Scala ayudará a entender los conceptos básicos para programar en este lenguaje.\n<br  />Se presentarán los temas con la posibilidad de ejecutar y modificar los ejemplos en la misma página de lectura para que pruebe y se familiarice con el lenguaje.</p>\n"}]},"apps":[],"jobName":"paragraph_1503270648230_1064968830","id":"20160818-202628_1132276461","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10961"},{"text":"%md ##Pattern Matching","dateUpdated":"2017-08-20T20:10:48-0300","config":{"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Pattern Matching</h2>\n"}]},"apps":[],"jobName":"paragraph_1503270648231_1064584081","id":"20160818-202628_880601097","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10962"},{"text":"%md Si usted conoce el lenguage Haskell siguiente ejemplo le resultará familiar.\nSi usted conoce lenguages imperativo como C o Java esta construcción es parecida a las sentencias `switch` con algunas diferencias:\n* La palabra clave `match` se escribe después de la variable (`selection match`) a diferencia de `switch selection` en los otros lenguajes.\n* No hace falta la sentencia `break`.\n* El caso por defecto es `case _` o `case x` donde `x` es cualquier identificador que comience con minúscula.\n\nPara más información ver\n* [Pattern Matching](http://docs.scala-lang.org/tutorials/tour/pattern-matching.html).","dateUpdated":"2017-08-20T20:10:48-0300","config":{"editorMode":"ace/mode/markdown","colWidth":6,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>Si usted conoce el lenguage Haskell siguiente ejemplo le resultará familiar.\n<br  />Si usted conoce lenguages imperativo como C o Java esta construcción es parecida a las sentencias <code>switch</code> con algunas diferencias:</p>\n<ul>\n<li>La palabra clave <code>match</code> se escribe después de la variable (<code>selection match</code>) a diferencia de <code>switch selection</code> en los otros lenguajes.</li>\n<li>No hace falta la sentencia <code>break</code>.</li>\n<li>El caso por defecto es <code>case _</code> o <code>case x</code> donde <code>x</code> es cualquier identificador que comience con minúscula.</li>\n</ul>\n<p>Para más información ver</p>\n<ul>\n<li><a href=\"http://docs.scala-lang.org/tutorials/tour/pattern-matching.html\">Pattern Matching</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503270648233_1062275587","id":"20160818-202628_959460339","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10963"},{"text":"val selection = \"Uno\"\nval selection_2 = \"Dos\"\nval selection_10 = \"Diez\"\n\nselection match {\n  case \"Uno\" => println(\"Seleccionó la opción Uno!\")  \n  case \"Dos\" => println(\"Seleccionó la opción Dos!\")  \n  case _ => println(\"Seleccionó otra cosa\")  \n}  ","user":"anonymous","dateUpdated":"2017-08-20T22:38:40-0300","config":{"editorMode":"ace/mode/scala","colWidth":6,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nselection: String = Uno\n\nselection_2: String = Dos\n\nselection_10: String = Diez\nSeleccionó la opción Uno!\n"}]},"apps":[],"jobName":"paragraph_1503270648235_1063045085","id":"20160818-202628_1592675188","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-20T22:38:28-0300","dateFinished":"2017-08-20T22:38:28-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10964"},{"text":"%md ## Currificación","dateUpdated":"2017-08-20T20:10:48-0300","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Currificación</h2>\n"}]},"apps":[],"jobName":"paragraph_1503270648235_1063045085","id":"20160818-202628_1953376262","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10965"},{"text":"%md &nbsp;\n\nLa currificación es una forma de definir funciones muy utilizada en los lenguajes funcionales.\nConsiste en definir sus parámetros de forma separada lo que permite usar la función predefiniendo parámetros.","dateUpdated":"2017-08-20T20:10:48-0300","config":{"colWidth":6,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>&nbsp;</p>\n<p>La currificación es una forma de definir funciones muy utilizada en los lenguajes funcionales.\n<br  />Consiste en definir sus parámetros de forma separada lo que permite usar la función predefiniendo parámetros.</p>\n"}]},"apps":[],"jobName":"paragraph_1503270648236_1061121341","id":"20160818-202628_654420514","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10966"},{"text":"def madd(x: Int, y: Int) = x + y // método \ndef madd_curry (x: Int)(y: Int) = x + y // método con currificación -- Funcion de funciones\nval fadd = (x: Int, y: Int) => x + y // función\nval fadd_curry = (x: Int) => (y: Int) => x + y // función con currificación\n\n// función que aplica una función \ndef aplicar(f: Int => Int, x: Int) = f(x)\n\naplicar(madd_curry(1), 10)\naplicar(fadd_curry(1), 10)\n\n// La siguiente funcion currifica funciones\nval curry = (f: (Int, Int) => Int) => (a: Int) => (b: Int) => f(a, b)\nval sumar = (x: Int, y: Int) => x + y\nval sumar_curry = curry(sumar)\nsumar_curry(1)(4)\n\ndef curry[A] (f: (A, A) => A) (a: A) (b: A) = f(a, b)\nval sumar1 = curry(sumar)(1) _ // función  de tipo Int => Int que suma 1\nsumar1(7)","user":"anonymous","dateUpdated":"2017-08-20T22:43:52-0300","config":{"colWidth":6,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nmadd: (x: Int, y: Int)Int\n\nmadd_curry: (x: Int)(y: Int)Int\n\nfadd: (Int, Int) => Int = <function2>\n\nfadd_curry: Int => (Int => Int) = <function1>\n\naplicar: (f: Int => Int, x: Int)Int\n\nres434: Int = 11\n\nres435: Int = 11\n\ncurry: ((Int, Int) => Int) => (Int => (Int => Int)) = <function1>\n\nsumar: (Int, Int) => Int = <function2>\n\nsumar_curry: Int => (Int => Int) = <function1>\n\nres438: Int = 5\n\ncurry: [A](f: (A, A) => A)(a: A)(b: A)A\n\nsumar1: Int => Int = <function1>\n\nres440: Int = 8\n"}]},"apps":[],"jobName":"paragraph_1503270648237_1060736592","id":"20160818-202628_521583258","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-20T22:43:52-0300","dateFinished":"2017-08-20T22:43:54-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10967"},{"text":"%md ##Colecciones","dateUpdated":"2017-08-20T20:10:48-0300","config":{"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Colecciones</h2>\n"}]},"apps":[],"jobName":"paragraph_1503270648238_1061890838","id":"20160818-202628_865069031","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10968"},{"title":"Arrays","text":"%md &nbsp;\n* Los arreglos se construyen con `Array(element1, element2, ...)`.\n* Internamente los arreglos en Scala son los arreglos primitivos de Java (`Array[Int]` en Scala es `int[]` de Java, `Array[String]` es `String[]` de Java, etc.).\n* Los arreglos son mutables (pueden modificar sus elementos aunque no su tamaño).\n* Para imprimirlos se puede usar su método `mkString` (ver ejemplo).\n* Los elementos de un arreglo pueden ser de cualquier tipo, pero el tipo final es la superclase común más cercana:\n```scala\n  class Foo(val value1:Int)\n  class Bar(value1:Int, val value2:Int) extends Foo(value1)\n  val list:Array[Foo] = Array(new Foo(1), new Bar(2,3))\n```\n\nPara mas información sobre ver: \n* [Documentación Scala sobre arreglos](http://www.scala-lang.org/api/current/index.html#scala.Array).","dateUpdated":"2017-08-20T20:10:48-0300","config":{"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>&nbsp;</p>\n<ul>\n<li>Los arreglos se construyen con <code>Array(element1, element2, ...)</code>.</li>\n<li>Internamente los arreglos en Scala son los arreglos primitivos de Java (<code>Array[Int]</code> en Scala es <code>int[]</code> de Java, <code>Array[String]</code> es <code>String[]</code> de Java, etc.).</li>\n<li>Los arreglos son mutables (pueden modificar sus elementos aunque no su tamaño).</li>\n<li>Para imprimirlos se puede usar su método <code>mkString</code> (ver ejemplo).</li>\n<li>Los elementos de un arreglo pueden ser de cualquier tipo, pero el tipo final es la superclase común más cercana:<pre><code class=\"scala\">class Foo(val value1:Int)\nclass Bar(value1:Int, val value2:Int) extends Foo(value1)\nval list:Array[Foo] = Array(new Foo(1), new Bar(2,3))\n</code></pre>\n</li>\n</ul>\n<p>Para mas información sobre ver:</p>\n<ul>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.Array\">Documentación Scala sobre arreglos</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503270648238_1061890838","id":"20160818-202628_908384136","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10969"},{"title":"Arrays","text":"def printArray[K](array: Array[K]) = array.mkString(\"Array(\" , \", \" , \")\")  \n\n//Arreglo de tipo Array[Int]  \nval array1 = Array(1, 2, 3)  \nprintArray(array1)//>Array(1, 2, 3)\n\n//Arreglo de tipo Array[String]  \nval array2 = Array(\"a\", \"b\", \"c\")\nprintArray(array2)  //>Array(a, b, c)  \n\n//Los valores se acceden con (index) no [index]    \nval itemAtIndex0 = array2(0)   //>itemAtIndex0 = a\n\n//de igual manera se modifican    \narray2(0) = \"d\"    \nprintArray(array2)  //>Array(d, b, c)  \n\n//Arreglo de tipo Array[Any]  \nval array3 = Array(\"a\", 2, true)\nprintArray(array3)//>Array(a, 2, true)  ","user":"anonymous","dateUpdated":"2017-08-20T22:46:07-0300","config":{"editorMode":"ace/mode/scala","colWidth":6,"editorHide":false,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nprintArray: [K](array: Array[K])String\n\narray1: Array[Int] = Array(1, 2, 3)\n\nres443: String = Array(1, 2, 3)\n\narray2: Array[String] = Array(a, b, c)\n\nres446: String = Array(a, b, c)\n\nitemAtIndex0: String = a\n\nres452: String = Array(d, b, c)\n\narray3: Array[Any] = Array(a, 2, true)\n\nres455: String = Array(a, 2, true)\n"}]},"apps":[],"jobName":"paragraph_1503270648239_1061506090","id":"20160818-202628_484322260","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-20T22:46:07-0300","dateFinished":"2017-08-20T22:46:09-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10970"},{"title":"Operaciones sobre Arrays","text":"val (array1, array3) = (Array(1, 2, 3), Array(\"a\", 2, true))\n//Para concatenar dos arreglos se usa el operador ++\n//Para agregar adelante se usa +: y atrás :+    \nval concatenated = \"adelante\" +: (array1 ++ array3) :+ \"atrás\"\nprintArray(concatenated)  //>Array(adelante, 1, 2, 3, a, 2, true, atrás)  \n\n//Para encontrar la posición de un elemento:\narray3.indexOf(2) //>1  \n\n//Búsqueda\nval personArray = Array((\"Pedro\", 1), (\"Kuka\", 2), (\"Porota\", 3))\ndef findByName(name: String) = personArray.find(_._1 == name).getOrElse((\"Lucas\", 4))  //>findByName(name = \"foo\") => (Lucas, 4)  \nval findPedro = findByName(\"Pedro\")  //>finPedro = (Pedro, 2)  \nval findMaria = findByName(\"Maria\")  //>findMaria = (Lucas, 4)  \n\nval pedroFound = findPedro._2  //>pedroFound = 1  \nval mariaFound = findMaria._2  //>mariaFound = 4  \n\n// Substracción\nval diffArray = Array(1, 2, 3, 4).diff(Array(3, 1))\nprintArray(diffArray) //>Array(2, 4) ","user":"anonymous","dateUpdated":"2017-08-20T22:52:06-0300","config":{"editorMode":"ace/mode/scala","colWidth":6,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\n\narray1: Array[Int] = Array(1, 2, 3)\narray3: Array[Any] = Array(a, 2, true)\n\nconcatenated: Array[Any] = Array(adelante, 1, 2, 3, a, 2, true, atrás)\n\nres494: String = Array(adelante, 1, 2, 3, a, 2, true, atrás)\n\nres497: Int = 1\n\npersonArray: Array[(String, Int)] = Array((Pedro,1), (Kuka,2), (Porota,3))\n\nfindByName: (name: String)(String, Int)\n\nfindPedro: (String, Int) = (Pedro,1)\n\nfindMaria: (String, Int) = (Lucas,4)\n\npedroFound: Int = 1\n\nmariaFound: Int = 4\n\ndiffArray: Array[Int] = Array(2, 4)\n\nres503: String = Array(2, 4)\n"}]},"apps":[],"jobName":"paragraph_1503270648240_1071894310","id":"20160818-202628_1782769927","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-20T22:52:06-0300","dateFinished":"2017-08-20T22:52:09-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10971"},{"title":"Listas","text":"%md\n\n* Las listas se construyen con `List(element1, element2, ...)`.\n* Los tipos de sus elementos pueden ser de cualquier tipo, pero el tipo final es la superclase común más cercana:\n```scala\n  class Foo(val value1:Int)\n  class Bar(value1:Int, val value2:Int) extends Foo(value1)\n  val list:List[Foo] = List(new Foo(1), new Bar(2,3))\n```\n* Las listas por defecto son **inmutables** (cualquier cambio crea una lista nueva, dejando la original tal cual). En el ejemplo siguiente se muestra como crear una mutable.\n* Están implementadas con listas ligadas por lo que agregar un elemento se hace a tiempo constante pero el acceso a un elemento es lineal.\n*  Se pueden concatenar listas mutables con inmutables, devolviendo el tipo inmutable. \n\nPara más información ver: \n* [Documentación Scala sobre listas](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List).","dateUpdated":"2017-08-20T20:10:48-0300","config":{"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<ul>\n<li>Las listas se construyen con <code>List(element1, element2, ...)</code>.</li>\n<li>Los tipos de sus elementos pueden ser de cualquier tipo, pero el tipo final es la superclase común más cercana:<pre><code class=\"scala\">class Foo(val value1:Int)\nclass Bar(value1:Int, val value2:Int) extends Foo(value1)\nval list:List[Foo] = List(new Foo(1), new Bar(2,3))\n</code></pre>\n</li>\n<li>Las listas por defecto son <strong>inmutables</strong> (cualquier cambio crea una lista nueva, dejando la original tal cual). En el ejemplo siguiente se muestra como crear una mutable.</li>\n<li>Están implementadas con listas ligadas por lo que agregar un elemento se hace a tiempo constante pero el acceso a un elemento es lineal.</li>\n<li>Se pueden concatenar listas mutables con inmutables, devolviendo el tipo inmutable.</li>\n</ul>\n<p>Para más información ver:</p>\n<ul>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List\">Documentación Scala sobre listas</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503270648241_1071509561","id":"20160818-202628_94254130","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10972"},{"title":"Listas","text":"//Listas inmutable con tipo List[Int]  \nval list1 = List(1, 2, 3) //> list1 = List(1, 2, 3)  \n//Listas inmutable con tipo List[Any]  \nval list2 = List(\"a\", 2, true) //> list2 = List(a, 2, true)  \nimport collection.mutable   \n//Listas mutables\nval mlist = mutable.ListBuffer(\"a\", \"b\", \"c\")  \n\n//Se accede con (indice) no [indice]   \nval firstItem = list1(0) //> firstItem = 1  \n\n//Se modifican sus valores de la misma forma (solo listas mutables)    \nmlist(0) = \"d\"    \nmlist //> ArrayBuffer(d, b, c)","user":"anonymous","dateUpdated":"2017-08-21T00:48:52-0300","config":{"editorMode":"ace/mode/scala","colWidth":6,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nlist1: List[Int] = List(1, 2, 3)\n\nlist2: List[Any] = List(a, 2, true)\n\nimport collection.mutable\n\nmlist: scala.collection.mutable.ListBuffer[String] = ListBuffer(a, b, c)\n\nfirstItem: Int = 1\n\nres512: scala.collection.mutable.ListBuffer[String] = ListBuffer(d, b, c)\n"}]},"apps":[],"jobName":"paragraph_1503270648241_1071509561","id":"20160818-202628_682874273","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T00:48:53-0300","dateFinished":"2017-08-21T00:48:55-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10973"},{"title":"Operaciones sobre Listas","text":"val (list1, list2) = (List(1, 2, 3), List(\"a\", 2, true))\n\n//Concatenacion con el operador ++ o ::: (solo listas)  \nlist1 ++ list2 //> List(1, 2, 3, a, 2, true)  \nlist1 ::: list2 //> List(1, 2, 3, a, 2, true)  \n\n//Para insertar adelante se usa :: (solo listas) or +:  \n0 :: list1 //> List(0, 1, 2, 3)  \n0 +: list1 //> List(0, 1, 2, 3)  \n\n//Para insertar atrás se usa :+ (poco eficiente para listas inmutables)  \nlist1 :+ 4 //> List(1, 2, 3, 4)  \n\nimport collection.mutable\nval mlist = mutable.ListBuffer(\"d\", \"b\", \"c\")\n//Todo junto:  \nval concatenated = 1 :: list1 ::: list2 ++ mlist :+ 'd' //> concatenated = List(1, 1, 2, 3, a, 2, true, d, b, c, d)  \n//La concatenación no modifica las listas originales     \nlist1 //> List(1, 2, 3) ","user":"anonymous","dateUpdated":"2017-08-21T00:49:15-0300","config":{"editorMode":"ace/mode/scala","colWidth":6,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\n\nlist1: List[Int] = List(1, 2, 3)\nlist2: List[Any] = List(a, 2, true)\n\nres515: List[Any] = List(1, 2, 3, a, 2, true)\n\nres516: List[Any] = List(1, 2, 3, a, 2, true)\n\nres519: List[Int] = List(0, 1, 2, 3)\n\nres520: List[Int] = List(0, 1, 2, 3)\n\nres523: List[Int] = List(1, 2, 3, 4)\n\nimport collection.mutable\n\nmlist: scala.collection.mutable.ListBuffer[String] = ListBuffer(d, b, c)\n\nconcatenated: List[Any] = List(1, 1, 2, 3, a, 2, true, d, b, c, d)\n\nres527: List[Int] = List(1, 2, 3)\n"}]},"apps":[],"jobName":"paragraph_1503270648242_1072663808","id":"20160818-202628_1495316381","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T00:49:15-0300","dateFinished":"2017-08-21T00:49:17-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10974"},{"title":"Operaciones Sobre Listas","text":"val (list1, list2) = (List(1, 2, 3), List(\"a\", 2, true))\nimport collection.mutable\nval mlist = mutable.ArrayBuffer(\"d\", \"b\", \"c\", \"f\")\n\n//Eliminación de elementos (solo listas mutables y crea una nueva):  \n//crea un arreglo nuevo con la \"c\" eliminada, mlist queda igual  \nmlist - \"c\" //> ArrayBuffer(d, b, f)  \n//crea un nuevo arreglo con e, f eliminados, mlist queda igual  \nmlist -- List(\"e\", \"f\") //> ArrayBuffer(d, b, c)  \n//mlist no se modifica  \nmlist //> ArrayBuffer(d, b, c, f)  \n\n//Eliminación de elementos, la lista si cambia (solo mutables):   \n//elimina c de la lista  \nmlist -= \"c\" //> ArrayBuffer(d, b, e, f, g)  \n//elimina e and f  \nmlist --= List(\"e\", \"f\") //> ArrayBuffer(d, b, e, f, g)  \nmlist //> ArrayBuffer(d, b)  \n\n//Agregar elelmentos, la lista si cambia (solo mutables)   \nmlist += \"e\" //> ArrayBuffer(d, b, e)  \nmlist ++= List(\"f\", \"g\") //> ArrayBuffer(d, b, e, f, g)  \nmlist //ArrayBuffer(d, b, e, f, g) //> ArrayBuffer(d, b, e, f, g)  ","user":"anonymous","dateUpdated":"2017-08-21T00:52:00-0300","config":{"editorMode":"ace/mode/scala","colWidth":6,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\n\nlist1: List[Int] = List(1, 2, 3)\nlist2: List[Any] = List(a, 2, true)\n\nimport collection.mutable\n\nmlist: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b, c, f)\n\nres572: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b, f)\n\nres574: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b, c)\n\nres576: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b, c, f)\n\nres580: mlist.type = ArrayBuffer(d, b, f)\n\nres582: mlist.type = ArrayBuffer(d, b)\n\nres583: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b)\n\nres586: mlist.type = ArrayBuffer(d, b, e)\n\nres587: mlist.type = ArrayBuffer(d, b, e, f, g)\n\nres588: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b, e, f, g)\n"}]},"apps":[],"jobName":"paragraph_1503270648243_1072279059","id":"20160818-202628_1871212485","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T00:52:00-0300","dateFinished":"2017-08-21T00:52:03-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10975"},{"title":"Operaciones sobre listas","text":"//Diff   \nval diffList = List(1, 2, 3, 4) diff List(2, 3) //> diffList = List(1, 4)  \n\nval personList = List((\"Pepe\", 1), (\"Carlos\", 2), (\"Kuka\", 3))\n\n//Búsqueda (devuelve la primer aparición)   \ndef findByName(name:String) = personList.find(_._1 == name).getOrElse((\"David\", 4)) //> findByName(name = \"foo\") => (David, 4)  \nval findPepe = findByName(\"Pepe\")  \nval findKuka = findByName(\"María\")  \n\nfindPepe._2 //> 1  \nfindKuka._2 //> 4","user":"anonymous","dateUpdated":"2017-08-21T00:52:43-0300","config":{"editorMode":"ace/mode/scala","colWidth":6,"editorHide":false,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndiffList: List[Int] = List(1, 4)\n\npersonList: List[(String, Int)] = List((Pepe,1), (Carlos,2), (Kuka,3))\n\nfindByName: (name: String)(String, Int)\n\nfindPepe: (String, Int) = (Pepe,1)\n\nfindKuka: (String, Int) = (David,4)\n\nres601: Int = 1\n\nres602: Int = 4\n"}]},"apps":[],"jobName":"paragraph_1503270648244_1070355314","id":"20160818-202628_442695254","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T00:52:43-0300","dateFinished":"2017-08-21T00:52:44-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10976"},{"title":"Sets","text":"%md\n* Los conjuntos se construyen con `Set(element1, element2, ...)`.\n* Pueden contener diferentes tipos. El tipo final es la superclase comun más cercana.\n* El tipo por defecto de los conjuntos es `Predef.Set` el cual es inmutable. En el ejemplo siguiente se muestra como crear uno mutable.\n* No admite duplicación de elementos. Al agregar uno que ya estaba se sobreescribe.\n\nPara más información ver\n* [scala.Predef](http://www.scala-lang.org/api/current/index.html#scala.Predef$).\n* [Documentación Scala sobre conjuntos](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Set).","dateUpdated":"2017-08-20T20:10:48-0300","config":{"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<ul>\n<li>Los conjuntos se construyen con <code>Set(element1, element2, ...)</code>.</li>\n<li>Pueden contener diferentes tipos. El tipo final es la superclase comun más cercana.</li>\n<li>El tipo por defecto de los conjuntos es <code>Predef.Set</code> el cual es inmutable. En el ejemplo siguiente se muestra como crear uno mutable.</li>\n<li>No admite duplicación de elementos. Al agregar uno que ya estaba se sobreescribe.</li>\n</ul>\n<p>Para más información ver</p>\n<ul>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.Predef$\">scala.Predef</a>.</li>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Set\">Documentación Scala sobre conjuntos</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503270648244_1070355314","id":"20160818-202628_846236849","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10977"},{"title":"Sets","text":"val set1 = Set(1, 2, 3) //Conjunto immutable de tipo Set[Int]  \nval set2 = Set(\"a\", 2, true) //Conjunto inmutable de tipo Set[Any]\n\nimport collection.mutable  \nval mset = mutable.HashSet(\"a\", \"b\", \"c\") // Versión mutable de conjunto \n\n//No admite duplicados\nprintln(Set(1, 2, 3, 2, 4, 3, 2, 1, 2)) //Set(1, 2, 3, 4)  \n\n//Pertenece   \nval oneExists = set1(1)  \nval fourExists = set1(4)  \nprintln(oneExists) // true  \nprintln(fourExists) // false  \n// Se puede usar mset(\"a\") = false pero no es recomendado","user":"anonymous","dateUpdated":"2017-08-25T18:58:06-0300","config":{"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nset1: scala.collection.immutable.Set[Int] = Set(1, 2, 3)\n\nset2: scala.collection.immutable.Set[Any] = Set(a, 2, true)\n\nimport collection.mutable\n\nmset: scala.collection.mutable.HashSet[String] = Set(c, a, b)\nSet(1, 2, 3, 4)\n\noneExists: Boolean = true\n\nfourExists: Boolean = false\ntrue\nfalse\n"}]},"apps":[],"jobName":"paragraph_1503270648245_1069970565","id":"20160818-202628_514472829","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T00:54:22-0300","dateFinished":"2017-08-21T00:54:24-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10978"},{"title":"Operaciones sobre Sets","text":"val set1 = (Set(1, 2, 3), Set(\"a\", 2, true))\nimport collection.mutable  \nval mset = mutable.HashSet(\"a\", \"b\", \"c\")\n\n//Concatenación (remueve duplicados)  \nval concatenated = set1 ++ set2 ++ mset  \nprintln(concatenated) // Set(1, a, true, 2, b, 3, c)  \n//Concatenacion no modifica los conjuntos originales   \nprintln(set1) //Set(1, 2, 3)  \n\n// Se pueden eliminar elementos de los conjuntos mutables\nmset -= \"c\"  \nprintln (mset) //Set(\"b\")  \n// Se puede usar mset(\"a\") = false pero no es recomendado\n\n","dateUpdated":"2017-08-21T00:54:50-0300","config":{"editorMode":"ace/mode/scala","colWidth":6,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503270648245_1069970565","id":"20160818-202628_322430640","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10979"},{"title":"Operaciones sobre Sets","text":"//Agregar solo en conjuntos mutables  \nmset += \"e\"  \nmset ++= Set(\"f\", \"g\")  \n\nprintln (mset) //Set(f, g, e, b)  \n//Diff  \nval diffSet = Set(1, 2, 3, 4) diff Set(2, 3)  \nprintln(diffSet) // Set(1, 4)  \n\n//Búsqueda  \nval personSet = Set((\"Pepe\", 1), (\"Carlos\", 2), (\"Kuka\", 3))  \ndef findByName(name: String) = personSet.find(_._1 == name).getOrElse((\"David\", 4))  \nval findPepe = findByName(\"Pepe\")  \nval findKuka = findByName(\"Maria\")  \n\nprintln(findPepe._2) //1  \nprintln(findKuka._2) //4  \n// Para búsqueda sobre claves es mejor usa Map (lo veremos mas adelante)","user":"anonymous","dateUpdated":"2017-08-21T00:56:34-0300","config":{"editorMode":"ace/mode/scala","colWidth":6,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres614: mset.type = Set(c, e, a, b)\n\nres615: mset.type = Set(f, c, g, e, a, b)\nSet(f, c, g, e, a, b)\n\ndiffSet: scala.collection.immutable.Set[Int] = Set(1, 4)\nSet(1, 4)\n\npersonSet: scala.collection.immutable.Set[(String, Int)] = Set((Pepe,1), (Carlos,2), (Kuka,3))\n\nfindByName: (name: String)(String, Int)\n\nfindPepe: (String, Int) = (Pepe,1)\n\nfindKuka: (String, Int) = (David,4)\n1\n4\n"}]},"apps":[],"jobName":"paragraph_1503270648245_1069970565","id":"20160818-202628_2147400601","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T00:56:34-0300","dateFinished":"2017-08-21T00:56:36-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10980"},{"title":"Maps","text":"%md &nbsp;\n* Los *Maps* se construyen con `Map(key1 -> value1, key2 -> value2, ...)`\n* Pueden almacenar diferentes tipos, pero el tipo final de las claves/valores serán la superclase común más cercana.\n* El `Map` por defecto (`Predef.Map`) es inmutable.\n* No se pueden tener claves duplicadas. Si se agrega un par clave/valor que ya existe se sobreescribe.\n\nVer también:\n* [scala.Predef](http://www.scala-lang.org/api/current/index.html#scala.Predef$).\n* [Documentación Scala sobre maps](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map).","dateUpdated":"2017-08-20T20:10:48-0300","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>&nbsp;</p>\n<ul>\n<li>Los <em>Maps</em> se construyen con <code>Map(key1 -&gt; value1, key2 -&gt; value2, ...)</code></li>\n<li>Pueden almacenar diferentes tipos, pero el tipo final de las claves/valores serán la superclase común más cercana.</li>\n<li>El <code>Map</code> por defecto (<code>Predef.Map</code>) es inmutable.</li>\n<li>No se pueden tener claves duplicadas. Si se agrega un par clave/valor que ya existe se sobreescribe.</li>\n</ul>\n<p>Ver también:</p>\n<ul>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.Predef$\">scala.Predef</a>.</li>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map\">Documentación Scala sobre maps</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503270648246_1071124812","id":"20160818-202628_107159126","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10981"},{"title":"Maps","text":"val map = Map(\"one\" -> 1, \"two\" -> 2, \"three\" -> 3)   \n//Map de tipo Map[String, Int]  \n\n//Maps elimina duplicados de las claves:  \nprintln(Map(\"a\" -> 1, \"a\" -> 2)) //Map(a -> 2)  \n\n//Tomar un elemento según clave usando map(key)   \nval one = map(\"one\")  \nprintln(one) // 1 \n\n// Si la clave no existe lanza la exceptcion NoSuchElementException\n//val four = map(\"four\")\n// Hay que usar el método get que devuelve una Option (se explicará después)\nval fourExistsOption = map.get(\"four\")  \nprintln(fourExistsOption.isDefined) // false\nprintln(fourExistsOption)","user":"anonymous","dateUpdated":"2017-08-21T00:58:10-0300","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":false,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nmap: scala.collection.immutable.Map[String,Int] = Map(one -> 1, two -> 2, three -> 3)\nMap(a -> 2)\n\none: Int = 1\n1\n\nfourExistsOption: Option[Int] = None\nfalse\nNone\n"}]},"apps":[],"jobName":"paragraph_1503270648246_1071124812","id":"20160818-202628_718105164","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T00:58:10-0300","dateFinished":"2017-08-21T00:58:11-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10982"},{"title":"Operaciones sobre maps","text":"import collection.mutable  \nval mmap = mutable.HashMap(\"a\" -> 1, \"b\" -> 2 , \"c\" -> 3)   \n//la versión mutable del Map  \n\n//Se pueden agregar o modificar elementos con:\nmmap(\"d\") = 4   \nprintln(mmap) //Map(b -> 2, d -> 4, a -> 1, c -> 3)  \n\nval (map1, map2) = (Map(\"one\" -> 1, \"two\" -> 2, \"three\" -> 3), Map(1 -> \"one\", \"2\" -> 2.0, 3.0 -> false))   \n// map 1 es de tipo Map[String, Int] y map2 es de tipo Map[Any, Any]\n\n//Concatenación con ++   \n//(elimina duplicados, no mantiene el order)  \nval concatenated = map1 ++ map2 ++ mmap\nprintln(concatenated)   \n// Map(three -> 3, 1 -> one, two -> 2, a -> 1, b -> 2, 3.0 -> false, 2 -> 2.0, c -> 3, one -> 1, d -> 4)  \n//Concatenación no modifica los maps originales   \nprintln(map1) //Map(one -> 1, two -> 2, three -> 3) ","dateUpdated":"2017-08-21T00:59:19-0300","config":{"tableHide":false,"editorMode":"ace/mode/scala","colWidth":6,"editorHide":false,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503270648247_1070740063","id":"20160818-202628_543506175","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10983"},{"title":"Operaciones sobre maps","text":"import collection.mutable  \nval mmap = mutable.HashMap(\"a\" -> 1, \"b\" -> 2 , \"c\" -> 3) \n\n//Removing elements (mutable Sets only)  \nmmap -= \"c\"  \nprintln (mmap) //Map(b -> 2, a -> 1)  \n\n//Adding elements (mutable Lists only)  \nmmap += \"e\" -> 5  \nmmap ++= Map(\"f\" -> 6, \"g\" -> 7)  \nprintln (mmap) //Map(e -> 5, b -> 2, g -> 7, a -> 1, f -> 6)\n\n//Búsqueda  \nval personMap = Map((\"Pepe\", 1), (\"Carlos\", 2), (\"Kuka\", 3))  \ndef findByName(name: String) = personSet.find(_._1 == name).getOrElse((\"David\", 4))  \nval findPepe = findByName(\"Pepe\")  \nval findKuka = findByName(\"Maria\")  \n\nprintln(findPepe._2) //1  \nprintln(findKuka._2) //4  ","user":"anonymous","dateUpdated":"2017-08-21T01:00:37-0300","config":{"editorMode":"ace/mode/scala","colWidth":6,"title":true,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport collection.mutable\n\nmmap: scala.collection.mutable.HashMap[String,Int] = Map(b -> 2, a -> 1, c -> 3)\n\nres642: mmap.type = Map(b -> 2, a -> 1)\nMap(b -> 2, a -> 1)\n\nres646: mmap.type = Map(e -> 5, b -> 2, a -> 1)\n\nres647: mmap.type = Map(e -> 5, b -> 2, g -> 7, a -> 1, f -> 6)\nMap(e -> 5, b -> 2, g -> 7, a -> 1, f -> 6)\n\npersonMap: scala.collection.immutable.Map[String,Int] = Map(Pepe -> 1, Carlos -> 2, Kuka -> 3)\n\nfindByName: (name: String)(String, Int)\n\nfindPepe: (String, Int) = (Pepe,1)\n\nfindKuka: (String, Int) = (David,4)\n1\n4\n"}]},"apps":[],"jobName":"paragraph_1503270648249_1068431570","id":"20160818-202628_70411293","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T01:00:37-0300","dateFinished":"2017-08-21T01:00:40-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10984"},{"text":"%md ## Contenedores Mutables","dateUpdated":"2017-08-20T20:10:48-0300","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Contenedores Mutables</h2>\n"}]},"apps":[],"jobName":"paragraph_1503270648250_1069585816","id":"20160818-202628_440224611","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10985"},{"title":"Contenedores Mutables","text":"%md &nbsp;\nScala promueve el uso de contenedores inmutables como `List`, `Set` y `Map`. De todas maneras, hay veces que se necesitan las versiones mutables por cuestiones de eficiencia.\n\nComo ya vimos Scala provee las versiones mutables de los contenedores en `scala.colections.mutable`:\n\n* `ListBuffer` es la versión mutables de `List`. \n   Están implementadas con listas ligadas: al igual que `List`, agregar un elemento al principio o al final se hace a tiempo constante y el acceso a un elemento es a tiempo lineal.\n* `arrayBuffer` es otra versión mutable de `List`. \n  La diferencia con la anterior es que se implementa con arreglos: el acceso es a tiempo constante pero agregar un elemento al principio o al final es lineal.\n* `hashSet` es la versión mutable de `Set`.\n* `hashMap` es la versión mutable de `Map`.\n   Estas dós últimas tienen acceso y agregado constantes (casi siempre, se implementan con tablas hash).\n\nEs buena práctica de programación es agregar la palabra `mutable.` cuando se crean los contenedores, como muestra el ejemplo siguiente. \n\n---\n\n* Los contenedores mutables permiten agregar y borrar valores sin necesidad de hacer copia de todo el objeto.\n* Las asignaciones a si mismo `+=`, `++=`, `-=`, `--=` son métodos de todos los contenedores mutable.\nPara más información ver:\n* [BufferLike](http://www.scala-lang.org/api/current/index.html#scala.collection.mutable.BufferLike)","user":"anonymous","dateUpdated":"2017-08-21T01:01:58-0300","config":{"colWidth":6,"editorMode":"ace/mode/markdown","editorHide":true,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"tableHide":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>&nbsp;\n<br  />Scala promueve el uso de contenedores inmutables como <code>List</code>, <code>Set</code> y <code>Map</code>. De todas maneras, hay veces que se necesitan las versiones mutables por cuestiones de eficiencia.</p>\n<p>Como ya vimos Scala provee las versiones mutables de los contenedores en <code>scala.colections.mutable</code>:</p>\n<ul>\n<li><code>ListBuffer</code> es la versión mutables de <code>List</code>.\n<br  />Están implementadas con listas ligadas: al igual que <code>List</code>, agregar un elemento al principio o al final se hace a tiempo constante y el acceso a un elemento es a tiempo lineal.</li>\n<li><code>arrayBuffer</code> es otra versión mutable de <code>List</code>.\n<br  />La diferencia con la anterior es que se implementa con arreglos: el acceso es a tiempo constante pero agregar un elemento al principio o al final es lineal.</li>\n<li><code>hashSet</code> es la versión mutable de <code>Set</code>.</li>\n<li><code>hashMap</code> es la versión mutable de <code>Map</code>.\n<br  />Estas dós últimas tienen acceso y agregado constantes (casi siempre, se impelemntan con tablas hash).</li>\n</ul>\n<p>Es buena práctica de programación es agregar la palabra <code>mutable.</code> cuando se crean los contenedores, como muestra el ejemplo siguiente.</p>\n<hr />\n<ul>\n<li>Los contenedores mutables permiten agregar y borrar valores sin necesidad de hacer copia de todo el objeto.</li>\n<li>Las asignaciones a si mismo <code>+=</code>, <code>++=</code>, <code>-=</code>, <code>--=</code> son métodos de todos los contenedores mutable.\n<br  />Para más información ver:</li>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.collection.mutable.BufferLike\">BufferLike</a></li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503270648252_1067277323","id":"20160818-202628_1541660002","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10986"},{"title":"Contenedores Mutables","text":"import scala.collection.mutable  \n\nval arrayBuffer = mutable.ArrayBuffer(1, 2, 3)   \nval listBuffer = mutable.ListBuffer(\"a\", \"b\", \"c\")  \nval hashSet = mutable.Set(0.1, 0.2, 0.3)  \nval hashMap = mutable.Map(\"one\" -> 1, \"two\" -> 2)  ","user":"anonymous","dateUpdated":"2017-08-21T01:02:37-0300","config":{"colWidth":6,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport scala.collection.mutable\n\narrayBuffer: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3)\n\nlistBuffer: scala.collection.mutable.ListBuffer[String] = ListBuffer(a, b, c)\n\nhashSet: scala.collection.mutable.Set[Double] = Set(0.3, 0.2, 0.1)\n\nhashMap: scala.collection.mutable.Map[String,Int] = Map(one -> 1, two -> 2)\n"}]},"apps":[],"jobName":"paragraph_1503270648253_1066892574","id":"20160818-202628_1392017959","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T01:02:37-0300","dateFinished":"2017-08-21T01:02:38-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10987"},{"title":"Contenedores Mutables","text":"import scala.collection.mutable  \n\nval arrayBuffer = mutable.ArrayBuffer(1, 2, 3)   \nval listBuffer = mutable.ListBuffer(\"a\", \"b\", \"c\")  \nval hashMap = mutable.Map(\"one\" -> 1, \"two\" -> 2, \"three\" -> 3)  \n\narrayBuffer += 4  \nlistBuffer += \"d\"  \narrayBuffer -= 1  \nlistBuffer -= \"a\"  \nhashMap += \"four\" -> 4  \nhashMap -= \"one\"  \n\narrayBuffer ++= List(5, 6, 7)  \nhashMap ++= Map(\"five\" -> 5, \"six\" -> 6)  \nhashMap --= Set(\"one\", \"three\")  \n\n\nprintln(arrayBuffer)  \nprintln(listBuffer)  \nprintln(hashMap)  ","dateUpdated":"2017-08-20T20:10:48-0300","config":{"colWidth":6,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503270648254_1068046821","id":"20160818-202628_1881598052","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10988"},{"title":"Contenedores Inmutables con VAR","text":"%md Una observación más con `+=`, `++=`, `-=`, `-== `:\n* Para contenedores inmutables - no tienen estos métodos, pero si los declaramos con `var` en vez de `val` el compilador lo expande a `variable = variable op param` (ver el ejemplo).\n* Para contenedores mutables - son métodos del contenedor y lo modifican.","dateUpdated":"2017-08-20T20:10:48-0300","config":{"colWidth":6,"editorMode":"ace/mode/markdown","editorHide":true,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>Una observación más con <code>+=</code>, <code>++=</code>, <code>-=</code>, <code>-==</code>:</p>\n<ul>\n<li>Para contenedores inmutables - no tienen estos métodos, pero si los declaramos con <code>var</code> en vez de <code>val</code> el compilador lo expande a <code>variable = variable op param</code> (ver el ejemplo).</li>\n<li>Para contenedores mutables - son métodos del contenedor y lo modifican.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503270648254_1068046821","id":"20160818-202628_1262370177","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10989"},{"title":"Contenedores Inmutables con VAR","text":"import scala.collection.mutable  \n\nvar immutableSet = Set(1, 2, 3)   \n\nimmutableSet += 4   \n//es lo mismo que:  \nimmutableSet = immutableSet + 4  \n\n//para el caso mutable:\nval mutableSet = mutable.Set(1, 2, 3)    \n\nmutableSet += 4   \n// es lo mismo que:   \nmutableSet.+=(4)  \n\nprintln(immutableSet, mutableSet)  ","user":"anonymous","dateUpdated":"2017-08-21T01:04:14-0300","config":{"colWidth":6,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport scala.collection.mutable\n\nimmutableSet: scala.collection.immutable.Set[Int] = Set(1, 2, 3)\n\nimmutableSet: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)\n\nmutableSet: scala.collection.mutable.Set[Int] = Set(1, 2, 3)\n\nres686: mutableSet.type = Set(1, 2, 3, 4)\n\nres688: mutableSet.type = Set(1, 2, 3, 4)\n(Set(1, 2, 3, 4),Set(1, 2, 3, 4))\n"}]},"apps":[],"jobName":"paragraph_1503270648256_1053426363","id":"20160818-202628_660742043","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T01:04:14-0300","dateFinished":"2017-08-21T01:04:15-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10990"},{"text":"%md ## Clases","dateUpdated":"2017-08-20T20:10:48-0300","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Clases</h2>\n"}]},"apps":[],"jobName":"paragraph_1503270648256_1053426363","id":"20160818-202628_1614853851","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10991"},{"text":"%md &nbsp;\n* Las clases en Scala definen sus atributos con `val` (solo lectura) o `var` (lectura/escritura). \n* Los métodos se definen con `def` en la forma que ya vimos.\n* Notar en el ejemplo que el acceso a los atributos y métodos es uniforme lo que permite cambiar la implementación sin cambiar el código que lo usa<sup>1</sup>.\n* Para declarar metodos o variables privadas se antepone la palabra clave `private` (ver ejemplo).\n* En Scala se inicializa todo lo definido dentro del cuerpo de la clase al momento de instanciarla en un objeto (ver ejemplo).\n* Las clases de Scala están pensadas para escribir una mínima cantidad de código. Es por ello que los parámetros de la clase se convierten automáticamente en atributos de solo lectura o lectura/escritura anteponiendo `val` y `var`.\n\n---\n\n* **Case Classes**: Son clases igual que las vistas pero exportan sus parámetros para proveer **pattern matching** (igual que en el lenguaje Haskell).\n\nPara más información ver:\n* [Documentación Scala sobre case clases](http://docs.scala-lang.org/tutorials/tour/case-classes).\n* [Introduccion a tipos algebraicos en Scala](http://tpolecat.github.io/presentations/algebraic_types.html).\n\n---\n\n* **Objetos Singletones:** Se usan cuando se quiere definir una unidad (módulo) que contenga una serie de métodos y valores agrupados.\n* Son una sola instancia de una clase por lo que se aplica todo lo que vimos sobre clases.\n* Se usan también para crear un ejecutable autónomo agregando un método `main`.\n* La inicialización se produce al momento de acceder un método o atributo.\n\nPara más información ver:\n* [Documentación Scala sobre objetos singletón](http://docs.scala-lang.org/tutorials/tour/singleton-objects).\n\n\n-----\n######1: Ver [Principio de acceso uniforme](http://en.wikipedia.org/wiki/Uniform_access_principle).\n","dateUpdated":"2017-08-20T20:10:48-0300","config":{"colWidth":6,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>&nbsp;</p>\n<ul>\n<li>Las clases en Scala definen sus atributos con <code>val</code> (solo lectura) o <code>var</code> (lectura/escritura).</li>\n<li>Los métodos se definen con <code>def</code> en la forma que ya vimos.</li>\n<li>Notar en el ejemplo que el acceso a los atributos y métodos es uniforme lo que permite cambiar la implementación sin cambiar el código que lo usa<sup>1</sup>.</li>\n<li>Para declarar metodos o variables privadas se antepone la palabra clave <code>private</code> (ver ejemplo).</li>\n<li>En Scala se inicializa todo lo definido dentro del cuerpo de la clase al momento de instanciarla en un objeto (ver ejemplo).</li>\n<li>Las clases de Scala están pensadas para escribir una mínima cantidad de código. Es por ello que los parámetros de la clase se convierten automáticamente en atributos de solo lectura o lectura/escritura anteponiendo <code>val</code> y <code>var</code>.</li>\n</ul>\n<hr />\n<ul>\n<li><strong>Case Classes</strong>: Son clases igual que las vistas pero exportan sus parámetros para proveer <strong>pattern matching</strong> (igual que en el lenguaje Haskell).</li>\n</ul>\n<p>Para más información ver:</p>\n<ul>\n<li><a href=\"http://docs.scala-lang.org/tutorials/tour/case-classes\">Documentación Scala sobre case clases</a>.</li>\n<li><a href=\"http://tpolecat.github.io/presentations/algebraic_types.html\">Introduccion a tipos algebraicos en Scala</a>.</li>\n</ul>\n<hr />\n<ul>\n<li><strong>Objetos Singletones:</strong> Se usan cuando se quiere definir una unidad (módulo) que contenga una serie de métodos y valores agrupados.</li>\n<li>Son una sola instancia de una clase por lo que se aplica todo lo que vimos sobre clases.</li>\n<li>Se usan también para crear un ejecutable autónomo agregando un método <code>main</code>.</li>\n<li>La inicialización se produce al momento de acceder un método o atributo.</li>\n</ul>\n<p>Para más información ver:</p>\n<ul>\n<li><a href=\"http://docs.scala-lang.org/tutorials/tour/singleton-objects\">Documentación Scala sobre objetos singletón</a>.</li>\n</ul>\n<hr />\n<h6>1: Ver <a href=\"http://en.wikipedia.org/wiki/Uniform_access_principle\">Principio de acceso uniforme</a>.</h6>\n"}]},"apps":[],"jobName":"paragraph_1503270648256_1053426363","id":"20160818-202628_1268617587","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10992"},{"title":"Definición de una clase","text":"//Clase con una variable de solo lectura y un método\nclass Persona(nombre: String, apellido: String){  \n  val nombreCompleto = s\"$nombre $apellido\"\n  private var count: Int = 0\n  def saludo = {\n      count +=1\n      \"Hola $nombre $apellido!\"\n  }\n  def saludos(n: Int) = \"Hola \" * n + s\"$nombre $apellido!\"\n  def verCount = count\n}  \nval p = new Persona(\"Oso\", \"Fumarola\")\nprintln(p.saludo)  \nprintln(p.saludos(3))  \nprintln(p.nombreCompleto)\n//p.nombreCompleto = \"hola\" // Atributo solo lectura, da error\n\np.saludo\np.verCount","user":"anonymous","dateUpdated":"2017-08-21T01:06:26-0300","config":{"colWidth":6,"editorMode":"ace/mode/scala","title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndefined class Persona\n\np: Persona = Persona@3373c258\nHola $nombre $apellido!\nHola Hola Hola Oso Fumarola!\nOso Fumarola\n\nres705: String = Hola $nombre $apellido!\n\nres706: Int = 2\n"}]},"apps":[],"jobName":"paragraph_1503270648257_1053041614","id":"20160818-202628_1911910324","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T01:06:26-0300","dateFinished":"2017-08-21T01:06:26-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10993"},{"title":"Inicializacion","text":"import scala.collection.mutable\n\nclass Prueba{\n      val set = new mutable.HashSet[Any]\n      println(\"Inicializando!!!\")\n      set += \"Esto es un string\"  \n      set += 732                 \n      set += 'c'                 \n      set += true                \n      \n\n      def doSomething { println(\"Ya se inicializo el objeto pru!\") }\n    }\n\nval pru = new Prueba\n\npru.doSomething\n\nprintln(pru.set)\n\nval pru2 = new Prueba","user":"anonymous","dateUpdated":"2017-08-21T01:18:00-0300","config":{"colWidth":6,"editorMode":"ace/mode/scala","title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"ERROR","msg":[{"type":"TEXT","data":"\nimport scala.collection.mutable\n\n\n\n<console>:13: error: not found: value mutable\n             val set = new mutable.HashSet[Any]\n                           ^\n"}]},"apps":[],"jobName":"paragraph_1503270648257_1053041614","id":"20160818-202628_83801003","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T01:18:00-0300","dateFinished":"2017-08-21T01:18:00-0300","status":"ERROR","progressUpdateIntervalMs":500,"$$hashKey":"object:10994"},{"title":"Parámetros automáticos","text":"class Persona(val nombre: String, var apellido: String)\n\nval p = new Persona(\"Oso\",\"Fumarola\")\nprintln(p.nombre)  \nprintln(p.apellido)  \np.apellido = \"Yogui\"\nprintln(p.apellido)","user":"anonymous","dateUpdated":"2017-08-21T01:15:12-0300","config":{"colWidth":6,"editorMode":"ace/mode/scala","title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndefined class Persona\n\np: Persona = Persona@7718e039\nOso\nFumarola\n\np.apellido: String = Yogui\nYogui\n"}]},"apps":[],"jobName":"paragraph_1503270648257_1053041614","id":"20160818-202628_658870454","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T01:15:12-0300","dateFinished":"2017-08-21T01:15:13-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10995"},{"title":"Case Classes","text":"abstract class Mascota // El tipo de todos los constructores que siguen\n\ncase class Gato(nombre: String) extends Mascota\ncase class Pez(nombre: String) extends Mascota\ncase class Perro(nombre: String, edad: Int) extends Mascota\n\nval catulo: Mascota = Gato(\"Catulo\")\n\ndef hola(p: Mascota): String = \n  p match {\n    case Gato(n)      => \"Miau \" + n + \"!\"\n    case Pez(n)       => \"Hola pez \" + n + \".\"    \n    case Perro(n, _)  => \"Hola \" + n + \".\"    \n  }\n  \nhola(catulo)","user":"anonymous","dateUpdated":"2017-08-21T01:17:02-0300","config":{"colWidth":6,"editorMode":"ace/mode/scala","title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndefined class Mascota\n\ndefined class Gato\n\ndefined class Pez\n\ndefined class Perro\n\ncatulo: Mascota = Gato(Catulo)\n\nhola: (p: Mascota)String\n\nres731: String = Miau Catulo!\n"}]},"apps":[],"jobName":"paragraph_1503270648257_1053041614","id":"20160818-202628_434711538","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T01:17:02-0300","dateFinished":"2017-08-21T01:17:04-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10996"},{"title":"Objetos Singletones","text":"import scala.collection.mutable\n\nobject OPrueba{\n      val set = new mutable.HashSet[Any]\n      println(\"Inicializando!!!\")\n      set += \"Esto es un string\"  // add un string\n      set += 732                 // add un number\n      set += 'c'                 // add un character\n      set += true                // add un booleano\n      \n\n      def doSomething { println(\"Ya se inicializó.\") }\n    }\n    \nprintln(OPrueba.set)\nprintln(\"Todavía no se inicializó\")\nOPrueba.doSomething\n\nprintln(OPrueba.set)","user":"anonymous","dateUpdated":"2017-08-21T01:18:16-0300","config":{"colWidth":6,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport scala.collection.mutable\n\ndefined object OPrueba\nInicializando!!!\nSet(c, 732, Esto es un string, true)\nTodavía no se inicializó\nYa se inicializó.\nSet(c, 732, Esto es un string, true)\n"}]},"apps":[],"jobName":"paragraph_1503270648258_1054195860","id":"20160818-202628_391181019","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T01:18:16-0300","dateFinished":"2017-08-21T01:18:18-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10997"},{"text":"%md ##Más sobre Scala\n\nEste tutorial cubre solo los conceptos básicos del lenguaje Scala.\nPara un conocimiento más completo se recomienda leer: \n* [10 Scala One Liners to Impress Your Friends](https://gist.github.com/mkaz/d11f8f08719d6d27bab5).\n* [Conversión implícita](http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html) (complicado pero útil).\n* [A Tour of Scala](http://docs.scala-lang.org/tutorials/tour/tour-of-scala).\n","dateUpdated":"2017-08-20T20:10:48-0300","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":false,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Más sobre Scala</h2>\n<p>Este tutorial cubre solo los conceptos básicos del lenguaje Scala.\n<br  />Para un conocimiento más completo se recomienda leer:</p>\n<ul>\n<li><a href=\"https://gist.github.com/mkaz/d11f8f08719d6d27bab5\">10 Scala One Liners to Impress Your Friends</a>.</li>\n<li><a href=\"http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html\">Conversión implícita</a> (complicado pero útil).</li>\n<li><a href=\"http://docs.scala-lang.org/tutorials/tour/tour-of-scala\">A Tour of Scala</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503270648258_1054195860","id":"20160818-202628_1194782072","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:10998"},{"title":"FIN","text":"println(\"\"\"%html\n<script>\n    var heads = document.getElementsByTagName('h2');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        inner = inner.replace(/^[\\W\\d]+/, \"\");\n        heads[i].innerHTML = (i+1) + \".- \" + inner;\n        i++\n    }\n</script>\n\"\"\")","user":"anonymous","dateUpdated":"2017-08-21T01:18:54-0300","config":{"tableHide":true,"colWidth":12,"editorMode":"ace/mode/scala","editorHide":false,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<script>\n    var heads = document.getElementsByTagName('h2');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        inner = inner.replace(/^[\\W\\d]+/, \"\");\n        heads[i].innerHTML = (i+1) + \".- \" + inner;\n        i++\n    }\n</script>\n\n"}]},"apps":[],"jobName":"paragraph_1503270648258_1054195860","id":"20160818-202628_1129453015","dateCreated":"2017-08-20T20:10:48-0300","dateStarted":"2017-08-21T01:18:55-0300","dateFinished":"2017-08-21T01:18:55-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:10999"},{"text":"","dateUpdated":"2017-08-20T20:10:48-0300","config":{"colWidth":12,"editorHide":false,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503270648259_1053811112","id":"20160818-202628_1736609851","dateCreated":"2017-08-20T20:10:48-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:11000"}],"name":"Tutorial Scala (parte2)","id":"2CTAJBY4M","angularObjects":{"2CQY683MD:shared_process":[],"2CRGPDJTN:shared_process":[],"2CTZD3XCX:shared_process":[],"2CRMCDEQM:shared_process":[],"2CTAV9E28:shared_process":[],"2CRA7KCDA:shared_process":[],"2CQ81X7G5:shared_process":[],"2CRUQ6EVN:shared_process":[],"2CTHYC7X9:shared_process":[],"2CRHWDFYM:shared_process":[],"2CQJ7MXW5:shared_process":[],"2CQAR5VSM:shared_process":[],"2CRCFF6HB:shared_process":[],"2CTK8TR8Q:shared_process":[],"2CQN5Q87B:shared_process":[],"2CTW5YZGW:shared_process":[],"2CSR7EJVT:shared_process":[],"2CRUQ7EXT:shared_process":[],"2CRFFBRXJ:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}